## вступление

В процессе проектирования и разработки программного обеспечения, нам необходимо учитывать довольно много различных аспектов.
К примеру, требования конечного пользователя, бизнеса, заказчика, требования к инфраструктуре, нефункциональные требования, соответствия местным законодательствам, регуляторным ограничениям, ограничениям бюджета, ограничениям по времени и технологиям, а также требования к поддерживаемости решения.

## про важность качества поддерживаемости ПО

Поддерживаемость решения является одной из важнейших характеристик ПО.
Основные особенности этой характеристики включают читаемость кода, наличие документации, понятность архитектуры, возможность быстрой диагностики и исправления ошибок, легкость добавления новых функций.
Поддержка важна, т.к. это одна из фаз жизненного цикла ПО, которая наступает после передачи её в эксплуатацию. Поддержка это непрерывный процесс улучшения, оптимизации и устранения обнаруженных дефектов, адаптации под изменившиееся требования, изменение поведение пользователя и т.п.

## про что доклад

Мой доклад как раз про один из способов, который может помочь упростить поддержку и диагностику проблем в софте.
И этот способ - разметка программного кода - кодами ошибок.
Думаю все сразу узнали откуда эта картинка и я почти уверен что каждый гуглил по коду ошибки решение на форумах 


## что такое код ошибки

Для того чтобы мы понимали друг друга, введем несколько терминов

Исключения (Exceptions) - это механизм, который делает возможным обработку нетипичных или ошибочных ситуаций, когда в процессе исполнения программы мы стакливаемся с какой-либо проблемой и для информирования о проблеме в коде создаются исключения чтобы прервать сценарий который мы не сможем по объективным причинам завершить так, как это было задумано и нам необходимо либо её как то автоматически обработать и продолжить, либо предоставить информацию о проблеме пользователю.
В целом это позволяет сделать программу более надежной и предсказуемой. И такой механизм предусмотрен в большинстве языков программирования, но реализован он может быть по-разному.

Код ошибки (Error code) - это номер (или сочетания букв и цифр), который соответствует конкретной проблеме в работе программы.
Таким образом необходимо присвоить для каждого исключительного сценария свой уникальный код ошибки, сформированный по определенному правилу.

Например, мы не смогли оплатить заказ - причин для этого может быть огромное множество, а код ошибки поможет нам определить какой конкретно исключительный сценарий произошел. Например код ATM-51204 может означать недостаток средств на карте, а ATM-51011 недоступность банка эквайера.

## отличия от кода ошибки возврата / exit code

Важный дисклеймер. Исключения действительно делают нас сильнее.

В эпоху расцвета процедурного программирования синтаксис работы с ошибками был тривиален и основывался на том, что вернула функция. К примеру если функция возвращала TRUE — все хорошо, если же FALSE — то произошла ошибка. Помимо возврата true/false также применяли цифровой код ошибки.

Но с тех пор много воды утекло и были придуманы более удобные подходы

И сейчас многие рекомендуют использовать вместо возврата кодов ошибок - исключения в том числе сам Microsoft:
https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions#throw-exceptions-instead-of-returning-an-error-code

Они поясняют это тем, что исключения гарантируют, что сбои не останутся незамеченными, поскольку вызывающий код не проверил код возврата.
Действительно исключения удобней для разработки, т.к.
* Они позволяют нам разделить обработку ошибок и сам алгоритм;
* Не загромождать код проверками возвращаемых значений;
* Обрабатывать ошибки на верхних уровнях, если на текущем уровне не хватает данных для обработки.
* Классифицировать типы ошибок, обрабатывать похожие исключения одинаково, сопоставлять специфичным исключениям определенные обработчики.

Само собой исключения не даются бесплатно, особенно если исключение происходит где-нибудь глубоко на стеке (например в Middleware) и пробрасывается через массу машин состояний в асинхронном коде, а ловится на самом верхнем уровне.
Но стоимость исключений это не тема сегодняшнего доклада, поэтому просто скажу что исключения должны выбрасываться лишь в исключительных ситуациях, когда вы по объективным причинам не можете выполнить весь сценарий должным образом. А также не стоит использовать исключения просто ради управления потоком исполнения (иначе это будет эмуляция супер дорогой, и многими не любимый оператор безусловного перехода «go to») и анти-паттерном «exception driven development”

Так вот, код ошибки я предлагаю использовать совместно с исключениями, добавив соответствующее свойство.


## Какую мы проблему решаем?


как применять? и как плавно внедрять её, какие есть варианты (базовый эксепшн или простановку кода ошибки в Data существующих исключений)

как это нам поможет в диагностике проблем, обнаружения, устранения инцидентов, поисках пострадавших

observability: запись кода ошибки в логи, тэги sentry, сбор метрик кодов ошибок

у всего есть трейдофф - какие плюсы и минусы подхода

минусы: внутреннее желание в категоризации





профит:

Код ошибки предназначен для показа пользователю, чтобы он мог код ошибки сообщить в Help Desk вместе с обращением. В Help Desk по коду ошибки могут быстро найти в своей базе знаний информацию о сценарии, когда он возникает, что можно сделать чтобы решить проблему и что можно порекомендовать пользователю.





Кодов ошибок может быть очень много заведено на проекте,
и на каждый код ошибки могут быть заведены статейки на help.astral.ru, куда
мы при желании сможем направлять пользователя.

Исключения создаются как раз для того чтобы прервать процесс который мы не сможем
по объективным причинам завершить так, как это было задумано.

На коды ошибок также могут быть завязаны внешние и внутренние сервисы.
Поэтому так или иначе, это является публичным контрактом.

Отсюда вытекает, что коды ошибок должны быть иммутабельными и нельзя их переиспользовать если например какой-то код ошибки освободился.
Видишь новый сценарий - создаешь новый код ошибки.
Если ТП просит разделить коды ошибок для двух сценариев, чтобы быстрее определять в чем дело - делайте это.


Поэтому коды ошибок могут перемешиваться между собой, к примеру код AWR-50000 может говорить о проблеме при работе с бд
а AWR-50001 уже говорить о недоступности Identity или нам прислали вместо Guid какую-то дичь с которой мы не сможем работать.

Поэтому попытки как-либо структурировать и классифицировать эти коды ошибок не стоит того (напр. 45xxx, 54xxx),
это будет холиварно, долго и сложно определиться - потому что код ошибки может одновременно принадлежать нескольким категориям

Отсюда я и не особо рад инициативе, где заводится поверх BusinessException различные ветки исключений
потому что это попытка это всё категоризировать.
И это может повлечь за собой ошибки:
если какой то код ошибки жестко привязан (зашит) в конкретное исключение,
то во первых разработчик может подумать что это сделано для переиспользования и один и тот же код ошибки будет из разных мест вываливаться
во вторых если код ошибки прокидывать в кастомное исключение (динамически) - в коде могут ожидать разные типы - ValidationException, ControllableException
и если поменять тип исключения для кода ошибки, то обработчики не поймают их.

Тем не менее, недостатки подхода с кодами ошибок имеются - то что придется в Exception фильтрах писать
условия на разные коды ошибок - но имхо, потребность в этом должна быть крайне редкой и стараться избегать этого.






There is a difference between error codes and error return values.
An error code is for the user and help desk.
An error return value is a coding technique to indicate that your code has encountered an error.

One can implement error codes using error return values, but I would advice against that. Exceptions are the modern way to report errors, and there is no reason why they should not carry an error code within them.

This is how I would organize it (Note that points 2-6 are language agnostic):

* Use a custom exception type with an additional ErrorCode property. The catch in the main loop will report this field in the usual way (log file / error pop-up / error reply). Use the same exception type in all of your code.
* Do not start at 1 and don't use leading zeros. Keep all error codes to the same length, so a wrong error code is easy to spot. Starting at 1000 usually is good enough. Maybe add a leading 'E' to make them clearly identifiable for users (especially useful when the support desk has to instruct users how to spot the error code).
* Keep a list of all error codes, but don't do this in your code. Keep a short list on a wiki-page for developers, which they can easily edit when they need a new code. The help desk should have a separate list on their own wiki.
* Do not try to enforce a structure on the error codes. There will always be hard-to-classify errors and you don't want to discuss for hours whether an error should be in the 45xx group or in the 54xx group. Be pragmatic.
* Assign each throw in your code a separate code. Even though you think it's the same cause, the help desk might need to do different things in different cases. It's easier for them to have "E1234: See E1235" in their wiki, than to get the user to confess what he has done wrong.
* Split error codes if the help desk asks for it. A simple if (...) throw new FooException(1234, ".."); else throw new FooException(1235, ".."); line in your code might save half an hour for the help desk.
* And never forget that the purpose of the error codes is to make life easier for the help desk.





----------------------------------------------------------------------------------------------------------------

TODO: красиво оформить что лучше: enums или константы и исходя из этого уже вынести решение

enums

плюсы:
* возможность на этапе компиляции понять какие коды ошибок могут быть а значит и их диапазон. А тексты ошибок - заполнить атрибутами.
* все коды ошибок лежат в одном файле

минусы:
* надо перекомпилировать приложение для введения новых кодов ошибок коды ошибок зашиты в приложение, не загрузить извне

> этот минус можно оспорить, так как маловероятно что кто-то захочет ввести код ошибки без перекомпиляции. Исключение: если коды ошибок от внешней системы хочется запихнуть и дополнить метаданными - к примеру, мы поняли что начало приходить новый код ошибки и настроить его поведение обработки: Retryable и прочее.

* необходимо собирать код ошибки из значения enum + префикс в рантайме. А значит найти по коду ошибки в исходном коде не получится, а само собирание кода ошибки тратит лишние CPU циклы

----------------------------------------------------------------------------------------------------------------

коды ошибок зашиты в исходном коде в виде констант, а всё остальное выносится в конфигурацию (appsettings, etcd, consul etc)


плюсы:
* возможность подгружать описание кодов ошибок, менять их описание на лету без перекомпиляции (извне)
> коды ошибок можно вытаскивать при старте приложения из какого-нибудь Distributed config или из локальной базы данных
> для этой возможности потребуется сделать абстракцию подгрузчика, с дефолтной реализацией чтения из appsettings (IConfiguration)
* возможнось гибко назначить категории ошибкам в виде тэгов. А в коде Exception Filter может ловить ошибки по категориям
это также позволит назначить несколько категорий для одного кода ошибки
* использование констант вместо enum позволит найти по полному коду ошибки в исходном коде - ускорит навигацию и устранение проблем. А также это тупо быстрее, чем склеивать строки, хоть они и кэшируются.

минусы:
* Если в исходном коде будут зашиты только коды ошибок, а всё остальное подгружается отдельно из конфига, есть шанс что чёт забудется и не опишется. Плюс появляется 2 места куда надо идти смотреть за описанием ошибок
* что делать, если описание по коду ошибки не нашлось?




нужно добавить возможность также добавить локализацию, подгружая разные языки для кода ошибки


Можно комбинировать оба подхода:

Сделать generic-наследник от DomainException и закрыть enum'ом
с атрибутами и прочим

таким образом кто хочет указывает просто строкой
а кто хочет берет себе enum.


третий вариант: из конфига вычитать и сгенерить через source generator enum на его основе



TODO: подумать насчёт Observability этих исключений. В идеале, если можно триггерить события что ошибка произошла такая-то, без выброса исключения


TODO: для AspNetCore https://github.com/khellang/Middleware/tree/master/src/ProblemDetails


TODO: дефолтный код ошибки и title если не задано



